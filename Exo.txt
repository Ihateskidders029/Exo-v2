-- [[ Name: Eyo-Zen by Makhail07 ]] -- -- [[ Converted: By Melon ]] -- -- [[ Reanimate: By Emper ]] -- -- [[ Description: A free version is coming soon. ]] -- -- [[ Paid ]] -- -- [[ https://www.roblox.com/catalog/13456587428/Big-Torso-Black ]] -- -- [[ https://www.roblox.com/catalog/12410453217/Giants-Eye ]] -- -- [[ https://www.roblox.com/catalog/12587931735/top-hat ]] -- -- [[ https://www.roblox.com/catalog/12867841874/Tall-Rectangle-Head-Dark-Grey ]] -- -- [[ https://www.roblox.com/catalog/12867898930/Grey-Smiley-Rectangle-Head ]] -- -- [[ https://www.roblox.com/catalog/12867846420/Tall-Rectangle-Head-Grey ]] -- -- [[ https://www.roblox.com/catalog/12867904652/Light-Grey-Smiley-Rectangle-Head ]] -- game:GetService("StarterGui"):SetCore("SendNotification", { 	Title = "Melon's (FE) Converts/Scripts"; 	Text = "Thanks for using!"; 	Icon = "rbxthumb://type=Asset&id=11561641603&w=150&h=150"}) Duration = 3; if not game:IsLoaded() then 	game.Loaded:Wait() end local function FindInstance(Parent, ClassName, Name) 	for _, Instance in pairs(Parent:GetChildren()) do 		if Instance:IsA(ClassName) and Instance.Name == Name then 			return Instance 		end 	end end local function WaitForClass(Parent, ClassName) 	local Instance = Parent:FindFirstChildOfClass(ClassName) 	while not Instance and Parent do 		Parent.ChildAdded:Wait() 		Instance = Parent:FindFirstChildOfClass(ClassName) 	end 	return Instance end local function WaitForClassOfName(Parent, ...) 	local Instance = FindInstance(Parent, ...) 	while not Instance and Parent do 		Parent.ChildAdded:Wait() 		Instance = FindInstance(Parent, ...) 	end 	return Instance end local Fling = { } local Aligns = { } local Blacklist = { } local Accessories = { } local Attachments = { } local Instancenew = Instance.new local taskwait = task.wait local taskspawn = task.spawn local taskdefer = task.defer local mathabs = math.abs local mathcos = math.cos local mathrandom = math.random local stringmatch = string.match local osclock = os.clock local tableinsert = table.insert local tableclear = table.clear local tablefind = table.find local CFramenew = CFrame.new local CFrameAngles = CFrame.Angles local CFrameidentity = CFrame.identity local Vector3new = Vector3.new local Vector3zero = Vector3.zero local Sleep = CFrameidentity local Velocity = Vector3new(0, 16384, 0) local Angular = 0 local Linear = 0 local Workspace = game:FindFirstChildOfClass("Workspace") local CurrentCamera = Workspace.CurrentCamera local Players = game:FindFirstChildOfClass("Players") local LocalPlayer = Players.LocalPlayer local Mouse = LocalPlayer:GetMouse() local PostSimulation = game:FindFirstChildOfClass("RunService").PostSimulation local Character = LocalPlayer.Character local CharacterClone = Instancenew("Model") local StarterGui = game:FindFirstChildOfClass("StarterGui") local BindableEvent = Instancenew("BindableEvent") local UserInputService = game:FindFirstChildOfClass("UserInputService") local UserInputType = Enum.UserInputType local MouseButton1 = UserInputType.MouseButton1 local Touch = UserInputType.Touch local InputBegan = UserInputService.InputBegan:Connect(function(Input, GameProcessed) 	local Type = Input.UserInputType 	 	if not GameProcessed and ( Type == MouseButton1 or Type == Touch ) then 		local Target = Mouse.Target 		if Target and not Target.Anchored and not Target:IsDescendantOf(CharacterClone) and not Target:IsDescendantOf(Character) and not tablefind(Fling, Target) then 			local Parent = Target.Parent 			if Parent:IsA("Model") and Parent ~= Character and Parent:FindFirstChildOfClass("Humanoid") then 				local HumanoidRootPart = FindInstance(Parent, "BasePart", "HumanoidRootPart") or FindInstance(Parent, "BasePart", "Torso") or FindInstance(Parent, "BasePart", "Head") 				if HumanoidRootPart and not tablefind(Fling, HumanoidRootPart) then 					tableinsert(Fling, HumanoidRootPart) 					return 				end 			end 			tableinsert(Fling, Target) 		end 	end end) local function Part(Name, Size) 	local Part = Instancenew("Part") 	Part.Name = Name 	Part.Size = Size 	Part.Transparency = 1 	Part.Parent = CharacterClone 	return Part end local function Motor6D(Name, Part0, Part1, C0, C1) 	local Motor6D = Instancenew("Motor6D") 	Motor6D.Name = Name 	Motor6D.Part0 = Part0 	Motor6D.Part1 = Part1 	Motor6D.C0 = C0 	Motor6D.C1 = C1 	Motor6D.Parent = Part0 	return Motor6D end local function Attachment(Name, CFrame, Parent) 	local Attachment = Instancenew("Attachment") 	Attachment.Name = Name 	Attachment.CFrame = CFrame 	Attachment.Parent = Parent 	tableinsert(Attachments, Attachment) 	return Attachment end local LimbSize = Vector3new(1, 2, 1) local TorsoSize = Vector3new(2, 2, 1) local Head = Part("Head", Vector3new(2, 1, 1)) local Torso = Part("Torso", TorsoSize) local LeftArm = Part("Left Arm", LimbSize) local RightArm = Part("Right Arm", LimbSize) local LeftLeg = Part("Left Leg", LimbSize) local RightLeg = Part("Right Leg", LimbSize) local HumanoidRootPart = Part("HumanoidRootPart", TorsoSize) local FakeRA = Instance.new("Part") FakeRA.Size = Vector3.new(1,2,1) FakeRA.Transparency = 1 FakeRA.BrickColor = BrickColor.new("Institutional White") FakeRA.Parent = RightArm local FRAW = Instance.new("Weld") FRAW.Part0 = RightArm FRAW.Part1 = FakeRA FRAW.C0 = CFrame.new(0, 0, 0) FRAW.Parent = RightArm local FakeLA = Instance.new("Part") FakeLA.Size = Vector3.new(1,2,1) FakeLA.Transparency = 1 FakeLA.BrickColor = BrickColor.new("Institutional White") FakeLA.Parent = LeftArm local FLAW = Instance.new("Weld") FLAW.Part0 = LeftArm FLAW.Part1 = FakeLA FLAW.C0 = CFrame.new(0, 0, 0) FLAW.Parent = LeftArm local FakeH = Instance.new("Part") FakeH.Size = Vector3.new(1,1,1) FakeH.Transparency = 1 FakeH.BrickColor = BrickColor.new("Institutional White") FakeH.Parent = Head local FHW = Instance.new("Weld") FHW.Part0 = Head FHW.Part1 = FakeH FHW.C0 = CFrame.new(0, 0, 0) FHW.Parent = Head local Part = nil if Character then 	Part = FindInstance(Character, "BasePart", "HumanoidRootPart") or FindInstance(Character, "BasePart", "Head") or FindInstance(Character, "BasePart", "Torso") or FindInstance(Character, "BasePart", "UpperTorso") end if Part then 	HumanoidRootPart.CFrame = Part.CFrame else 	local SpawnLocations = { } 	for _, SpawnLocation in pairs(Workspace:GetDescendants()) do 		if SpawnLocation:IsA("SpawnLocation") then 			tableinsert(SpawnLocations, SpawnLocation) 		end 	end 	local Amount = # SpawnLocations 	if Amount > 0 then 		local SpawnLocation = SpawnLocations[mathrandom(1, Amount)] 		HumanoidRootPart.CFrame = SpawnLocation.CFrame * CFramenew(0, SpawnLocation.Size.Y / 2 + 3, 0) 	else 		HumanoidRootPart.CFrame = CFrameidentity 	end end local face = Instancenew("Decal") face.Name = "face" face.Parent = Head local AccessoryTable = { -- Paid -- -- stop stealing my align edits epiconister!!!!!!!!!!! - Melon { Mesh = "12587696102", Texture = "12587753316", Instance = FakeH, CFrame = CFramenew(0,2.45,0) }, { Mesh = "12410145311", Texture = "12404371983", Instance = Head, CFrame = CFramenew(0,0.75,0) }, 	{ Mesh = "13456570685", Texture = "13456570842", Instance = Torso }, 	{ Mesh = "https:/14768666349", Texture = "14768664565", Instance = RightArm, CFrame = CFrameAngles(0, 0, 0) * CFramenew(0.4,-0.45,0) }, 	{ Mesh = "12867814848", Texture = "12867873138", Instance = LeftArm, CFrame = CFrameAngles(0, 0, 0) * CFramenew(-0.4,-0.45,0) }, 	{ Mesh = "12867814848", Texture = "12794082919", Instance = RightLeg, CFrame = CFrameAngles(0, 0, 0) * CFramenew(0.25,-0.45,0) }, 	{ Mesh = "12867814848", Texture = "12794084950", Instance = LeftLeg, CFrame = CFrameAngles(0, 0, 0) * CFramenew(-0.25,-0.45,0) }, } for _, Table in pairs(AccessoryTable) do 	if type(Table.Mesh) ~= "string" then 		Table.Mesh = "" 	end 	if type(Table.Texture) ~= "string" then 		Table.Texture = "" 	end end Motor6D("Right Shoulder", Torso, RightArm, CFramenew(1, 0.5, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0), CFramenew(-0.5, 0.5, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)) Motor6D("Left Shoulder", Torso, LeftArm, CFramenew(-1, 0.5, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0), CFramenew(0.5, 0.5, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)) Motor6D("Right Hip", Torso, RightLeg, CFramenew(1, -1, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0), CFramenew(0.5, 1, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)) Motor6D("Left Hip", Torso, LeftLeg, CFramenew(-1, -1, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0), CFramenew(-0.5, 1, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)) Motor6D("Neck", Torso, Head, CFramenew(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0), CFramenew(0, -0.5, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)) Motor6D("RootJoint", HumanoidRootPart, Torso, CFramenew(0, 0, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0), CFramenew(0, 0, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)) Attachment("HairAttachment", CFramenew(0, 0.600000024, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), Head) Attachment("HatAttachment", CFramenew(0, 0.600000024, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), Head) Attachment("FaceFrontAttachment", CFramenew(0, 0, -0.600000024, 1, 0, 0, 0, 1, 0, 0, 0, 1), Head) Attachment("FaceCenterAttachment", CFramenew(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), Head) Attachment("NeckAttachment", CFramenew(0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), Torso) Attachment("BodyFrontAttachment", CFramenew(0, 0, -0.5, 1, 0, 0, 0, 1, 0, 0, 0, 1), Torso) Attachment("BodyBackAttachment", CFramenew(0, 0, 0.5, 1, 0, 0, 0, 1, 0, 0, 0, 1), Torso) Attachment("LeftCollarAttachment", CFramenew(-1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), Torso) Attachment("RightCollarAttachment", CFramenew(1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), Torso) Attachment("WaistFrontAttachment", CFramenew(0, -1, -0.5, 1, 0, 0, 0, 1, 0, 0, 0, 1), Torso) Attachment("WaistCenterAttachment", CFramenew(0, -1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), Torso) Attachment("WaistBackAttachment", CFramenew(0, -1, 0.5, 1, 0, 0, 0, 1, 0, 0, 0, 1), Torso) Attachment("LeftShoulderAttachment", CFramenew(0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), LeftArm) Attachment("LeftGripAttachment", CFramenew(0, -1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), LeftArm) Attachment("RightShoulderAttachment", CFramenew(0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), RightArm) Attachment("RightGripAttachment", CFramenew(0, -1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), RightArm) Attachment("LeftFootAttachment", CFramenew(0, -1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), LeftLeg) Attachment("RightFootAttachment", CFramenew(0, -1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), RightLeg) Attachment("RootAttachment", CFramenew(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), HumanoidRootPart) local Humanoid = Instancenew("Humanoid", CharacterClone) Humanoid.HipHeight = 1 Instancenew("Animator", Humanoid) Instancenew("LocalScript", CharacterClone).Name = "Animate" CharacterClone.PrimaryPart = Head CharacterClone.Parent = Workspace local function DescendantAdded(Instance) 	if Instance:IsA("Accessory") then 		taskspawn(function() 			local Handle = WaitForClassOfName(Instance, "BasePart", "Handle") 			local Attachment = WaitForClass(Handle, "Attachment") 			local Clone = Instance:Clone() 			local CloneHandle = FindInstance(Clone, "BasePart", "Handle") 			CloneHandle.Transparency = 1 			CloneHandle:BreakJoints() 			local AccessoryWeld = Instancenew("Weld") 			AccessoryWeld.Name = "AccessoryWeld" 			AccessoryWeld.Part0 = CloneHandle 			AccessoryWeld.C0 = Attachment.CFrame 			local Name = Attachment.Name 			for _, TableAttachment in pairs(Attachments) do 				if TableAttachment.Name == Name then 					AccessoryWeld.Part1 = TableAttachment.Parent 					AccessoryWeld.C1 = TableAttachment.CFrame 				end 			end 			AccessoryWeld.Parent = CloneHandle 			Clone.Parent = CharacterClone 			tableinsert(Accessories, Clone) 			local IsAMeshPart = CloneHandle:IsA("MeshPart") 			local Mesh = IsAMeshPart and CloneHandle or WaitForClass(CloneHandle, "SpecialMesh") 			local Id = IsAMeshPart and "TextureID" or "TextureId" 			for _, Table in pairs(AccessoryTable) do 				local Instance = Table.Instance 				if Instance then 					if stringmatch(Mesh.MeshId, Table.Mesh) and stringmatch(Mesh[Id], Table.Texture) and not tablefind(Blacklist, Instance) then 						tableinsert(Blacklist, Instance) 						tableinsert(Aligns, { Handle, Instance, Table.CFrame or CFrameidentity }) 						return 					end 				end 			end 			tableinsert(Aligns, { Handle, CloneHandle, CFrameidentity }) 		end) 	elseif Instance:IsA("JointInstance") then 		taskspawn(function() 			taskwait() 			Instance:Destroy() 		end) 	end end local function CharacterAdded(Character) 	if Character ~= CharacterClone then		 		PostSimulation:Wait() 		local Backpack = LocalPlayer:FindFirstChildOfClass("Backpack") 		if Backpack then 			Backpack:ClearAllChildren() 		end 		tableclear(Aligns) 		tableclear(Blacklist) 		for _, Accessory in pairs(Accessories) do 			Accessory:Destroy() 		end 		local CurrentCameraCFrame = CurrentCamera.CFrame 		LocalPlayer.Character = CharacterClone 		CurrentCamera.CameraSubject = CharacterClone.Head 		taskspawn(function() 			CurrentCamera:GetPropertyChangedSignal("CFrame"):Wait() 			CurrentCamera.CFrame = CurrentCameraCFrame 		end) 		local CharacterHumanoidRootPart = WaitForClassOfName(Character, "BasePart", "HumanoidRootPart") 		for Index, Value in pairs(Fling) do 			local BasePart = nil 			if typeof(Value) == "Instance" then 				if Value:IsA("BasePart") then 					BasePart = Value 				elseif Value:IsA("Humanoid") then 					local Model = Value.Parent 					if Model ~= Character and Model:IsA("Model") then 						BasePart = FindInstance(Model, "BasePart", "HumanoidRootPart") or FindInstance(Model, "BasePart", "Head") or Model:FindFirstChildOfClass("BasePart") 					end 				elseif Value:IsA("Model") and Value ~= Character then 					BasePart = FindInstance(Value, "BasePart", "HumanoidRootPart") or FindInstance(Value, "BasePart", "Head") or Value:FindFirstChildOfClass("BasePart") 				end 			end 			if BasePart then 				local clock = osclock() 				while CharacterHumanoidRootPart and BasePart and osclock() - clock <= 1 and BasePart.AssemblyLinearVelocity.Magnitude <= 60 do 					CharacterHumanoidRootPart.AssemblyAngularVelocity = Velocity 					CharacterHumanoidRootPart.AssemblyLinearVelocity = Velocity 					CharacterHumanoidRootPart.CFrame = BasePart.CFrame + Vector3new(0, - 1, 0) 					PostSimulation:Wait() 				end 			end 		end 		tableclear(Fling) 		if CharacterHumanoidRootPart then 			CharacterHumanoidRootPart.AssemblyAngularVelocity = Vector3zero 			CharacterHumanoidRootPart.AssemblyLinearVelocity = Vector3zero 			CharacterHumanoidRootPart.CFrame = CFramenew(HumanoidRootPart.Position + Vector3new(mathrandom(- 32, 32), 0, mathrandom(- 32, 32))) 			PostSimulation:Wait() 		end 		Character:BreakJoints() 		for _, Instance in pairs(Character:GetDescendants()) do 			DescendantAdded(Instance) 		end 		Character.DescendantAdded:Connect(DescendantAdded) 	end end local function Align(Part0, Part1, CFrame) 	if Part0.ReceiveAge == 0 and not Part0.Anchored and # Part0:GetJoints() == 0 then 		Part0.AssemblyAngularVelocity = Vector3new(0, Angular, 0) 		local Part1CFrame = Part1.CFrame 		local LinearVelocity = Part1.AssemblyLinearVelocity * Linear 		local Magnitude = LinearVelocity.Magnitude < Linear 		if Magnitude then 			local LookVector = Part1CFrame.LookVector * Linear 			Part0.AssemblyLinearVelocity = Vector3new(LookVector.X, Linear, LookVector.Z) 		else 			Part0.AssemblyLinearVelocity = Vector3new(LinearVelocity.X, Linear, LinearVelocity.Z) 		end 		Part0.CFrame = Part1CFrame * ( Magnitude and Sleep or CFrameidentity ) * CFrame 	end end if Character then 	CharacterAdded(Character) end local Added = LocalPlayer.CharacterAdded:Connect(CharacterAdded) local Connection = game:FindFirstChildOfClass("RunService").PostSimulation:Connect(function() 	local osclock = osclock() 	local Axis = 0.004 * mathcos(osclock * 17.5) 	Sleep = CFramenew(0, Axis, 0) 	Angular = mathcos(osclock) 	Linear = 26 	for _, Table in pairs(Aligns) do 		Align(Table[1], Table[2], Table[3]) 	end 	if sethiddenproperty then 		sethiddenproperty(LocalPlayer, "SimulationRadius", 10000000) 	end 	StarterGui:SetCore("ResetButtonCallback", BindableEvent) -- This is if it gets overriden, just like in MyWorld testing place. end) local function Event() 	CharacterClone:Destroy() end BindableEvent.Event:Connect(Event) CharacterClone:GetPropertyChangedSignal("Parent"):Connect(function() 	if not CharacterClone.Parent then 		Added:Disconnect() 		Connection:Disconnect() 		CharacterClone:Destroy() 		if BindableEvent then 			BindableEvent:Destroy() 		end 		StarterGui:SetCore("ResetButtonCallback", true) 	end end) BindableEvent:GetPropertyChangedSignal("Parent"):Connect(Event) game:GetService("StarterGui"):SetCore("SendNotification", { 	Title = "Melon's (FE) Converts/Scripts"; 	Text = "Loaded successfully!"; 	Icon = "rbxthumb://type=Asset&id=11561641603&w=150&h=150"}) Duration = 3; --A script By makhail07 wait() local plr = game:service'Players'.LocalPlayer print('Local User is '..plr.Name) local char = plr.Character local hum = char.Humanoid local hed = char.Head local root = char.HumanoidRootPart local rootj = root.RootJoint local tors = char.Torso local ra = char["Right Arm"] local la = char["Left Arm"] local rl = char["Right Leg"] local ll = char["Left Leg"] local neck = tors["Neck"] local mouse = plr:GetMouse() local RootCF = CFrame.fromEulerAnglesXYZ(-1.57, 0, 3.14) local RHCF = CFrame.fromEulerAnglesXYZ(0, 1.6, 0) local LHCF = CFrame.fromEulerAnglesXYZ(0, -1.6, 0) local maincolor = BrickColor.new("Institutional white") ------------------------------------------------------- --Start Good Stuff-- ------------------------------------------------------- cam = game.Workspace.CurrentCamera CF = CFrame.new angles = CFrame.Angles attack = false Euler = CFrame.fromEulerAnglesXYZ Rad = math.rad IT = Instance.new BrickC = BrickColor.new Cos = math.cos Acos = math.acos Sin = math.sin Asin = math.asin Abs = math.abs Mrandom = math.random Floor = math.floor ------------------------------------------------------- --End Good Stuff-- ------------------------------------------------------- necko = CF(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0) RSH, LSH = nil, nil RW = Instance.new("Weld") LW = Instance.new("Weld") RH = tors["Right Hip"] LH = tors["Left Hip"] RSH = tors["Right Shoulder"] LSH = tors["Left Shoulder"] RSH.Parent = nil LSH.Parent = nil RW.Name = "RW" RW.Part0 = tors RW.C0 = CF(1.5, 0.5, 0) RW.C1 = CF(0, 0.5, 0) RW.Part1 = ra RW.Parent = tors LW.Name = "LW" LW.Part0 = tors LW.C0 = CF(-1.5, 0.5, 0) LW.C1 = CF(0, 0.5, 0) LW.Part1 = la LW.Parent = tors Effects = {} ------------------------------------------------------- --Start HeartBeat-- ------------------------------------------------------- ArtificialHB = Instance.new("BindableEvent", script) ArtificialHB.Name = "Heartbeat" script:WaitForChild("Heartbeat") frame = 1 / 60 tf = 0 allowframeloss = false tossremainder = false lastframe = tick() script.Heartbeat:Fire() game:GetService("RunService").Heartbeat:connect(function(s, p) 	tf = tf + s 	if tf >= frame then 		if allowframeloss then 			script.Heartbeat:Fire() 			lastframe = tick() 		else 			for i = 1, math.floor(tf / frame) do 				script.Heartbeat:Fire() 			end 			lastframe = tick() 		end 		if tossremainder then 			tf = 0 		else 			tf = tf - frame * math.floor(tf / frame) 		end 	end end) ------------------------------------------------------- --End HeartBeat-- ------------------------------------------------------- ------------------------------------------------------- --Start Important Functions-- ------------------------------------------------------- function swait(num) 	if num == 0 or num == nil then 		game:service("RunService").Stepped:wait(0) 	else 		for i = 0, num do 			game:service("RunService").Stepped:wait(0) 		end 	end end function thread(f) 	coroutine.resume(coroutine.create(f)) end function clerp(a, b, t) 	local qa = { 		QuaternionFromCFrame(a) 	} 	local qb = { 		QuaternionFromCFrame(b) 	} 	local ax, ay, az = a.x, a.y, a.z 	local bx, by, bz = b.x, b.y, b.z 	local _t = 1 - t 	return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t)) end function QuaternionFromCFrame(cf) 	local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components() 	local trace = m00 + m11 + m22 	if trace > 0 then 		local s = math.sqrt(1 + trace) 		local recip = 0.5 / s 		return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5 	else 		local i = 0 		if m00 < m11 then 			i = 1 		end 		if m22 > (i == 0 and m00 or m11) then 			i = 2 		end 		if i == 0 then 			local s = math.sqrt(m00 - m11 - m22 + 1) 			local recip = 0.5 / s 			return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip 		elseif i == 1 then 			local s = math.sqrt(m11 - m22 - m00 + 1) 			local recip = 0.5 / s 			return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip 		elseif i == 2 then 			local s = math.sqrt(m22 - m00 - m11 + 1) 			local recip = 0.5 / s 			return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip 		end 	end end function QuaternionToCFrame(px, py, pz, x, y, z, w) 	local xs, ys, zs = x + x, y + y, z + z 	local wx, wy, wz = w * xs, w * ys, w * zs 	local xx = x * xs 	local xy = x * ys 	local xz = x * zs 	local yy = y * ys 	local yz = y * zs 	local zz = z * zs 	return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy)) end function QuaternionSlerp(a, b, t) 	local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4] 	local startInterp, finishInterp 	if cosTheta >= 1.0E-4 then 		if 1 - cosTheta > 1.0E-4 then 			local theta = math.acos(cosTheta) 			local invSinTheta = 1 / Sin(theta) 			startInterp = Sin((1 - t) * theta) * invSinTheta 			finishInterp = Sin(t * theta) * invSinTheta 		else 			startInterp = 1 - t 			finishInterp = t 		end 	elseif 1 + cosTheta > 1.0E-4 then 		local theta = math.acos(-cosTheta) 		local invSinTheta = 1 / Sin(theta) 		startInterp = Sin((t - 1) * theta) * invSinTheta 		finishInterp = Sin(t * theta) * invSinTheta 	else 		startInterp = t - 1 		finishInterp = t 	end 	return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp end function rayCast(Position, Direction, Range, Ignore) 	return game:service("Workspace"):FindPartOnRay(Ray.new(Position, Direction.unit * (Range or 999.999)), Ignore) end ------------------------------------------------------- --Start Damage Function-- ------------------------------------------------------- function Damage(Part, hit, minim, maxim, knockback, Type, Property, Delay, HitSound, HitPitch) end ------------------------------------------------------- --End Damage Function-- ------------------------------------------------------- ------------------------------------------------------- --Start Damage Function Customization-- ------------------------------------------------------- function ShowDamage(Pos, Text, Time, Color) 	local Rate = (1 / 30) 	local Pos = (Pos or Vector3.new(0, 0, 0)) 	local Text = (Text or "") 	local Time = (Time or 2) 	local Color = (Color or Color3.new(1, 0, 1)) 	local EffectPart = CFuncs.Part.Create(workspace, "SmoothPlastic", 0, 1, BrickColor.new(Color), "Effect", Vector3.new(0, 0, 0)) 	EffectPart.Anchored = true 	local BillboardGui = Create("BillboardGui"){ 		Size = UDim2.new(3, 0, 3, 0), 		Adornee = EffectPart, 		Parent = EffectPart, 	} 	local TextLabel = Create("TextLabel"){ 		BackgroundTransparency = 1, 		Size = UDim2.new(1, 0, 1, 0), 		Text = Text, 		Font = "Bodoni", 		TextColor3 = Color, 		TextScaled = true, 		TextStrokeColor3 = Color3.fromRGB(0,0,0), 		Parent = BillboardGui, 	} 	game.Debris:AddItem(EffectPart, (Time)) 	EffectPart.Parent = game:GetService("Workspace") 	delay(0, function() 		local Frames = (Time / Rate) 		for Frame = 1, Frames do 			wait(Rate) 			local Percent = (Frame / Frames) 			EffectPart.CFrame = CFrame.new(Pos) + Vector3.new(0, Percent, 0) 			TextLabel.TextTransparency = Percent 		end 		if EffectPart and EffectPart.Parent then 			EffectPart:Destroy() 		end 	end) end ------------------------------------------------------- --End Damage Function Customization-- ------------------------------------------------------- function MagniDamage(Part, magni, mindam, maxdam, knock, Type) end CFuncs = { 	Part = { 		Create = function(Parent, Material, Reflectance, Transparency, BColor, Name, Size) 			local Part = Create("Part")({ 				Parent = Parent, 				Reflectance = Reflectance, 				Transparency = Transparency, 				CanCollide = false, 				Locked = true, 				BrickColor = BrickColor.new(tostring(BColor)), 				Name = Name, 				Size = Size, 				Material = Material 			}) 			RemoveOutlines(Part) 			return Part 		end 	}, 	Mesh = { 		Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale) 			local Msh = Create(Mesh)({ 				Parent = Part, 				Offset = OffSet, 				Scale = Scale 			}) 			if Mesh == "SpecialMesh" then 				Msh.MeshType = MeshType 				Msh.MeshId = MeshId 			end 			return Msh 		end 	}, 	Mesh = { 		Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale) 			local Msh = Create(Mesh)({ 				Parent = Part, 				Offset = OffSet, 				Scale = Scale 			}) 			if Mesh == "SpecialMesh" then 				Msh.MeshType = MeshType 				Msh.MeshId = MeshId 			end 			return Msh 		end 	}, 	Weld = { 		Create = function(Parent, Part0, Part1, C0, C1) 			local Weld = Create("Weld")({ 				Parent = Parent, 				Part0 = Part0, 				Part1 = Part1, 				C0 = C0, 				C1 = C1 			}) 			return Weld 		end 	}, 	Sound = { 		Create = function(id, par, vol, pit) 			coroutine.resume(coroutine.create(function() 				local S = Create("Sound")({ 					Volume = vol, 					Pitch = pit or 1, 					SoundId = id, 					Parent = par or workspace 				}) 				wait() 				S:play() 				game:GetService("Debris"):AddItem(S, 6) 			end)) 		end 	}, 	ParticleEmitter = { 		Create = function(Parent, Color1, Color2, LightEmission, Size, Texture, Transparency, ZOffset, Accel, Drag, LockedToPart, VelocityInheritance, EmissionDirection, Enabled, LifeTime, Rate, Rotation, RotSpeed, Speed, VelocitySpread) 			local fp = Create("ParticleEmitter")({ 				Parent = Parent, 				Color = ColorSequence.new(Color1, Color2), 				LightEmission = LightEmission, 				Size = Size, 				Texture = Texture, 				Transparency = Transparency, 				ZOffset = ZOffset, 				Acceleration = Accel, 				Drag = Drag, 				LockedToPart = LockedToPart, 				VelocityInheritance = VelocityInheritance, 				EmissionDirection = EmissionDirection, 				Enabled = Enabled, 				Lifetime = LifeTime, 				Rate = Rate, 				Rotation = Rotation, 				RotSpeed = RotSpeed, 				Speed = Speed, 				VelocitySpread = VelocitySpread 			}) 			return fp 		end 	} } function RemoveOutlines(part) 	part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10 end function CreatePart(FormFactor, Parent, Material, Reflectance, Transparency, BColor, Name, Size) 	local Part = Create("Part")({ 		formFactor = FormFactor, 		Parent = Parent, 		Reflectance = Reflectance, 		Transparency = Transparency, 		CanCollide = false, 		Locked = true, 		BrickColor = BrickColor.new(tostring(BColor)), 		Name = Name, 		Size = Size, 		Material = Material 	}) 	RemoveOutlines(Part) 	return Part end function CreateMesh(Mesh, Part, MeshType, MeshId, OffSet, Scale) 	local Msh = Create(Mesh)({ 		Parent = Part, 		Offset = OffSet, 		Scale = Scale 	}) 	if Mesh == "SpecialMesh" then 		Msh.MeshType = MeshType 		Msh.MeshId = MeshId 	end 	return Msh end function CreateWeld(Parent, Part0, Part1, C0, C1) 	local Weld = Create("Weld")({ 		Parent = Parent, 		Part0 = Part0, 		Part1 = Part1, 		C0 = C0, 		C1 = C1 	}) 	return Weld end ------------------------------------------------------- --Start Effect Function-- ------------------------------------------------------- EffectModel = Instance.new("Model", char) Effects = { Block = { Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, Type) local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new()) prt.Anchored = true prt.CFrame = cframe local msh = CFuncs.Mesh.Create("BlockMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1)) game:GetService("Debris"):AddItem(prt, 10) if Type == 1 or Type == nil then table.insert(Effects, { prt, "Block1", delay, x3, y3, z3, msh }) elseif Type == 2 then table.insert(Effects, { prt, "Block2", delay, x3, y3, z3, msh }) else table.insert(Effects, { prt, "Block3", delay, x3, y3, z3, msh }) end end }, Sphere = { Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay) local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new()) prt.Anchored = true prt.CFrame = cframe local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1)) game:GetService("Debris"):AddItem(prt, 10) table.insert(Effects, { prt, "Cylinder", delay, x3, y3, z3, msh }) end }, Cylinder = { Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay) local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new()) prt.Anchored = true prt.CFrame = cframe local msh = CFuncs.Mesh.Create("CylinderMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1)) game:GetService("Debris"):AddItem(prt, 10) table.insert(Effects, { prt, "Cylinder", delay, x3, y3, z3, msh }) end }, Wave = { Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay) local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new()) prt.Anchored = true prt.CFrame = cframe local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://20329976", Vector3.new(0, 0, 0), Vector3.new(x1 / 60, y1 / 60, z1 / 60)) game:GetService("Debris"):AddItem(prt, 10) table.insert(Effects, { prt, "Cylinder", delay, x3 / 60, y3 / 60, z3 / 60, msh }) end }, Ring = { Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay) local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new()) prt.Anchored = true prt.CFrame = cframe local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://3270017", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1)) game:GetService("Debris"):AddItem(prt, 10) table.insert(Effects, { prt, "Cylinder", delay, x3, y3, z3, msh }) end }, Break = { Create = function(brickcolor, cframe, x1, y1, z1) local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new(0.5, 0.5, 0.5)) prt.Anchored = true prt.CFrame = cframe * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)) local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1)) local num = math.random(10, 50) / 1000 game:GetService("Debris"):AddItem(prt, 10) table.insert(Effects, { prt, "Shatter", num, prt.CFrame, math.random() - math.random(), 0, math.random(50, 100) / 100 }) end }, Spiral = { Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay) local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new()) prt.Anchored = true prt.CFrame = cframe local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://1051557", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1)) game:GetService("Debris"):AddItem(prt, 10) table.insert(Effects, { prt, "Cylinder", delay, x3, y3, z3, msh }) end }, Push = { Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay) local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new()) prt.Anchored = true prt.CFrame = cframe local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://437347603", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1)) game:GetService("Debris"):AddItem(prt, 10) table.insert(Effects, { prt, "Cylinder", delay, x3, y3, z3, msh }) end } } function part(formfactor ,parent, reflectance, transparency, brickcolor, name, size) 	local fp = IT("Part") 	fp.formFactor = formfactor 	fp.Parent = parent 	fp.Reflectance = reflectance 	fp.Transparency = transparency 	fp.CanCollide = false 	fp.Locked = true 	fp.BrickColor = brickcolor 	fp.Name = name 	fp.Size = size 	fp.Position = tors.Position 	RemoveOutlines(fp) 	fp.Material = "SmoothPlastic" 	fp:BreakJoints() 	return fp end function mesh(Mesh,part,meshtype,meshid,offset,scale) 	local mesh = IT(Mesh) 	mesh.Parent = part 	if Mesh == "SpecialMesh" then 		mesh.MeshType = meshtype 	if meshid ~= "nil" then 		mesh.MeshId = "http://www.roblox.com/asset/?id="..meshid 		end 	end 	mesh.Offset = offset 	mesh.Scale = scale 	return mesh end function Magic(bonuspeed, type, pos, scale, value, color, MType) 	local type = type 	local rng = Instance.new("Part", char) 	rng.Anchored = true 	rng.BrickColor = color 	rng.CanCollide = false 	rng.FormFactor = 3 	rng.Name = "Ring" 	rng.Material = "Neon" 	rng.Size = Vector3.new(1, 1, 1) 	rng.Transparency = 0 	rng.TopSurface = 0 	rng.BottomSurface = 0 	rng.CFrame = pos 	local rngm = Instance.new("SpecialMesh", rng) 	rngm.MeshType = MType 	rngm.Scale = scale 	local scaler2 = 1 	if type == "Add" then 		scaler2 = 1 * value 	elseif type == "Divide" then 		scaler2 = 1 / value 	end 	coroutine.resume(coroutine.create(function() 		for i = 0, 10 / bonuspeed, 0.1 do 			swait() 			if type == "Add" then 				scaler2 = scaler2 - 0.01 * value / bonuspeed 			elseif type == "Divide" then 				scaler2 = scaler2 - 0.01 / value * bonuspeed 			end 			rng.Transparency = rng.Transparency + 0.01 * bonuspeed 			rngm.Scale = rngm.Scale + Vector3.new(scaler2 * bonuspeed, scaler2 * bonuspeed, scaler2 * bonuspeed) 		end 		rng:Destroy() 	end)) end function Eviscerate(dude) end function FindNearestHead(Position, Distance, SinglePlayer) 	if SinglePlayer then 		return Distance > (SinglePlayer.Torso.CFrame.p - Position).magnitude 	end 	local List = {} 	for i, v in pairs(workspace:GetChildren()) do 		if v:IsA("Model") and v:findFirstChild("Head") and v ~= char and Distance >= (v.Head.Position - Position).magnitude then 			table.insert(List, v) 		end 	end 	return List end function Aura(bonuspeed, FastSpeed, type, pos, x1, y1, z1, value, color, outerpos, MType) 	local type = type 	local rng = Instance.new("Part", char) 	rng.Anchored = true 	rng.BrickColor = color 	rng.CanCollide = false 	rng.FormFactor = 3 	rng.Name = "Ring" 	rng.Material = "Neon" 	rng.Size = Vector3.new(1, 1, 1) 	rng.Transparency = 0 	rng.TopSurface = 0 	rng.BottomSurface = 0 	rng.CFrame = pos 	rng.CFrame = rng.CFrame + rng.CFrame.lookVector * outerpos 	local rngm = Instance.new("SpecialMesh", rng) 	rngm.MeshType = MType 	rngm.Scale = Vector3.new(x1, y1, z1) 	local scaler2 = 1 	local speeder = FastSpeed 	if type == "Add" then 		scaler2 = 1 * value 	elseif type == "Divide" then 		scaler2 = 1 / value 	end 	coroutine.resume(coroutine.create(function() 		for i = 0, 10 / bonuspeed, 0.1 do 			swait() 			if type == "Add" then 				scaler2 = scaler2 - 0.01 * value / bonuspeed 			elseif type == "Divide" then 				scaler2 = scaler2 - 0.01 / value * bonuspeed 			end 			speeder = speeder - 0.01 * FastSpeed * bonuspeed 			rng.CFrame = rng.CFrame + rng.CFrame.lookVector * speeder * bonuspeed 			rng.Transparency = rng.Transparency + 0.01 * bonuspeed 			rngm.Scale = rngm.Scale + Vector3.new(scaler2 * bonuspeed, scaler2 * bonuspeed, 0) 		end 		rng:Destroy() 	end)) end function FaceMouse() local	Cam = workspace.CurrentCamera 	return { 		CFrame.new(char.Torso.Position, Vector3.new(mouse.Hit.p.x, char.Torso.Position.y, mouse.Hit.p.z)), 		Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z) 	} end ------------------------------------------------------- --End Effect Function-- ------------------------------------------------------- function Cso(ID, PARENT, VOLUME, PITCH) 	local NSound = nil 	coroutine.resume(coroutine.create(function() 		NSound = IT("Sound", PARENT) 		NSound.Volume = VOLUME 		NSound.Pitch = PITCH 		NSound.SoundId = "http://www.roblox.com/asset/?id="..ID 		swait() 		NSound:play() 		game:GetService("Debris"):AddItem(NSound, 10) 	end)) 	return NSound end function CameraEnshaking(Length, Intensity) 	coroutine.resume(coroutine.create(function() 		local intensity = 1 * Intensity 		local rotM = 0.01 * Intensity 		for i = 0, Length, 0.1 do 			swait() 			intensity = intensity - 0.05 * Intensity / Length 			rotM = rotM - 5.0E-4 * Intensity / Length 			hum.CameraOffset = Vector3.new(Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity))) 			cam.CFrame = cam.CFrame * CF(Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity))) * Euler(Rad(Mrandom(-intensity, intensity)) * rotM, Rad(Mrandom(-intensity, intensity)) * rotM, Rad(Mrandom(-intensity, intensity)) * rotM) 		end 		hum.CameraOffset = Vector3.new(0, 0, 0) 	end)) end ------------------------------------------------------- --End Important Functions-- ------------------------------------------------------- ------------------------------------------------------- --Start Customization-- ------------------------------------------------------- local Player_Size = 1 if Player_Size ~= 1 then root.Size = root.Size * Player_Size tors.Size = tors.Size * Player_Size hed.Size = hed.Size * Player_Size ra.Size = ra.Size * Player_Size la.Size = la.Size * Player_Size rl.Size = rl.Size * Player_Size ll.Size = ll.Size * Player_Size ---------------------------------------------------------------------------------- rootj.Parent = root neck.Parent = tors RW.Parent = tors LW.Parent = tors RH.Parent = tors LH.Parent = tors ---------------------------------------------------------------------------------- rootj.C0 = RootCF * CF(0 * Player_Size, 0 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0)) rootj.C1 = RootCF * CF(0 * Player_Size, 0 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0)) neck.C0 = necko * CF(0 * Player_Size, 0 * Player_Size, 0 + ((1 * Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)) neck.C1 = CF(0 * Player_Size, -0.5 * Player_Size, 0 * Player_Size) * angles(Rad(-90), Rad(0), Rad(180)) RW.C0 = CF(1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0)) --* RIGHTSHOULDERC0 LW.C0 = CF(-1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0)) --* LEFTSHOULDERC0 ---------------------------------------------------------------------------------- RH.C0 = CF(1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0)) LH.C0 = CF(-1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0)) RH.C1 = CF(0.5 * Player_Size, 1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0)) LH.C1 = CF(-0.5 * Player_Size, 1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0)) --hat.Parent = Character end ---------------------------------------------------------------------------------- local SONG = 1494452913 local SONG2 = 1130685064 local Music = Instance.new("Sound",tors) Music.Volume = 2.5 Music.Looped = true Music.Pitch = 1 --Pitcher ---------------------------------------------------------------------------------- local equipped = false local idle = 0 local change = 1 local val = 0 local toim = 0 local idleanim = 0.4 local sine = 0 local Sit = 1 ---------------------------------------------------------------------------------- hum.WalkSpeed = 10 hum.JumpPower = 57 hum.Animator.Parent = nil ---------------------------------------------------------------------------------- local naeeym2 = IT("BillboardGui",char) naeeym2.AlwaysOnTop = true naeeym2.Size = UDim2.new(5,35,2,15) naeeym2.StudsOffset = Vector3.new(0,2,0) naeeym2.MaxDistance = 75 naeeym2.Adornee = hed naeeym2.Name = "Name" --naeeym2.PlayerToHideFrom = Player local tecks2 = IT("TextLabel",naeeym2) tecks2.BackgroundTransparency = 1 tecks2.TextScaled = true tecks2.BorderSizePixel